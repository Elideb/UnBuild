using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace UnBuild {

    /// <summary>
    /// Class to create and build configurations, and execute the
    /// build process from Unity scripts.
    /// Note: using this functionality requires Unity Pro (as of Unity 4.3)
    /// Use BuildConfiguration.Create to get a clean configuration,
    /// set, add and remove methods to customize it
    /// and Build to create the desired executable.
    /// Each call to methods which modify settings create a new configuration
    /// and return it, so previous configurations are not overwritten.
    /// Check the example to check how to take advantadge of it.
    /// </summary>
    /// <example>
    /// // Create a configuration with common parameters for builds.
    /// BuildConfiguration baseConfig = BuildConfiguration.Create()
    ///                                                   .SetExecName("CoolName")
    ///                                                   .AddScene("OutlineTest")
    ///                                                   .AddBuildOption(BuildOptions.ShowBuiltPlayer)
    ///                                                   .AddBuildOption(BuildOptions.AutoRunPlayer)
    ///                                                   .AddBuildOption(BuildOptions.Development)
    ///                                                   .RemoveBuildOption(BuildOptions.AutoRunPlayer)
    ///                                                   .AddFileMapping("Sprites/Ship.png", "Ship.png")
    ///                                                   .AddDirMapping("Sprites", "Sprites");
    ///
    /// // Create a basic windows build
    /// baseConfig.SetTargetDir("../../Builds/Win")
    ///           .Build(BuildTarget.StandaloneWindows);
    ///
    /// // Create a Linux build with customized settings.
    /// // Each call to base config methods (except build)
    /// // generates a new configuration, so baseConfig remains unchanged.
    /// baseConfig.SetTargetDir("../../Builds/linux_x86")
    ///           .SetExecName(baseConfig.ExecName.ToLower())
    ///           .RemoveBuildOption(BuildOptions.AutoRunPlayer)
    ///           .Build(BuildTarget.StandaloneLinux);
    ///
    /// // Retains the original exec name and auto run setting.
    /// baseConfig.SetTargetDir("../../Builds/OSXUniversal")
    ///           .Build(BuildTarget.StandaloneOSXUniversal);
    /// </example>
    public class BuildConfiguration {

        string targetDir;
        /// <summary>
        /// Get the directory where the build will be generated.
        /// </summary>
        public string TargetDir { get { return this.targetDir; } }

        string execName;
        /// <summary>
        /// Get the name of the executable to generate, sans extensions.
        /// </summary>
        public string ExecName { get { return this.execName; } }

        List<string> scenes;
        BuildOptions options;
        /// <summary>
        /// Get the currently configured build options.
        /// </summary>
        public BuildOptions Options { get { return this.options; } }

        public enum LineEnd {
            Windows,
            Unix,
        }

        private abstract class TextFile {
            private readonly string file;
            public string File { get { return file; } }

            public abstract string LineEnding { get; }

            public TextFile(string file) {
                this.file = file;
            }
        }

        private class WindowsTextFile : TextFile {
            public override string LineEnding {
                get { return "\r\n"; }
            }

            public WindowsTextFile(string file)
                : base(file) {
            }
        }

        private class UnixTextFile : TextFile {
            public override string LineEnding {
                get { return "\n"; }
            }

            public UnixTextFile(string file)
                : base(file) {
            }
        }

        private class SystemCommand {
            public string Command { get; private set; }
            public string Path { get; private set; }

            public string Output { get; private set; }

            public SystemCommand(string program, string path) {
                this.Command = program;
                this.Path = path;
            }

            /// <summary>
            /// Execute the command in a console/terminal opened at the specified path.
            /// </summary>
            /// <param name="basePath">Base path to open the terminal in.</param>
            /// <returns>The output generated by the command.</returns>
            public string Execute(string basePath) {
                this.Output = string.Empty;

                System.Diagnostics.ProcessStartInfo startInfo = new System.Diagnostics.ProcessStartInfo();
                startInfo.UseShellExecute = false;
#if UNITY_EDITOR_WIN
                startInfo.FileName = "cmd.exe";
#elif UNITY_EDITOR_OSX
				startInfo.FileName = "/Applications/Utilities/Terminal.app/Contents/MacOS/Terminal";
#endif
                startInfo.EnvironmentVariables["PATH"] = System.Environment.GetEnvironmentVariable("PATH");
                startInfo.WorkingDirectory = basePath;
                startInfo.RedirectStandardInput = true;
                startInfo.RedirectStandardOutput = true;
                startInfo.RedirectStandardError = true;

                System.Diagnostics.Process process = new System.Diagnostics.Process();
                process.StartInfo = startInfo;
                process.OutputDataReceived += ReadCommandLineOutput;
                process.ErrorDataReceived += ReadCommandLineOutput;

                process.Start();
                process.BeginOutputReadLine();
                process.BeginErrorReadLine();
                using (System.IO.StreamWriter cmdWriter = new System.IO.StreamWriter(process.StandardInput.BaseStream, new System.Text.UTF8Encoding(false))) {
                    cmdWriter.WriteLine("cd " + this.Path);
                    cmdWriter.WriteLine(this.Command);
                }

                process.WaitForExit();
                process.CancelOutputRead();
                process.CancelErrorRead();

                return this.Output;
            }

            private void ReadCommandLineOutput(object sender, System.Diagnostics.DataReceivedEventArgs e) {
                this.Output += e.Data + System.Environment.NewLine;
            }
        }

        Dictionary<string, string> dirMappings;
        Dictionary<string, string> fileMappings;
        Dictionary<TextFile, string> textFileMappings;
        Dictionary<string, string> buildFilesToCopy;
        HashSet<string> filesToDelete;
        HashSet<string> dirsToCreate;
        HashSet<string> dirsToDelete;
        List<SystemCommand> prebuildCommands;
        List<SystemCommand> postbuildCommands;

        public BuildConfiguration() {
            this.scenes = new List<string>();
            this.dirMappings = new Dictionary<string, string>();
            this.fileMappings = new Dictionary<string, string>();
            this.textFileMappings = new Dictionary<TextFile, string>();
            this.buildFilesToCopy = new Dictionary<string, string>();
            this.filesToDelete = new HashSet<string>();
            this.dirsToCreate = new HashSet<string>();
            this.dirsToDelete = new HashSet<string>();
            this.prebuildCommands = new List<SystemCommand>();
            this.postbuildCommands = new List<SystemCommand>();
            this.options = BuildOptions.None;
        }

        /// <summary>
        /// Copy constructor.
        /// </summary>
        /// <param name="other">Configuration to replicate.</param>
        public BuildConfiguration(BuildConfiguration other) {
            this.scenes = new List<string>(other.scenes);

            this.dirMappings = new Dictionary<string, string>(other.dirMappings);
            this.fileMappings = new Dictionary<string, string>(other.fileMappings);
            this.textFileMappings = new Dictionary<TextFile, string>(other.textFileMappings);
            this.buildFilesToCopy = new Dictionary<string, string>(other.buildFilesToCopy);
            this.filesToDelete = new HashSet<string>(other.filesToDelete);
            this.dirsToCreate = new HashSet<string>(other.dirsToCreate);
            this.dirsToDelete = new HashSet<string>(other.dirsToDelete);
            this.prebuildCommands = new List<SystemCommand>(other.prebuildCommands);
            this.postbuildCommands = new List<SystemCommand>(other.postbuildCommands);

            this.options = other.Options;
            this.targetDir = other.targetDir;
            this.execName = other.execName;
        }

        /// <summary>
        /// Create a clean configuration.
        /// </summary>
        /// <returns>A new build configuration.</returns>
        public static BuildConfiguration Create() {
            return new BuildConfiguration();
        }

        /// <summary>
        /// Set the name of the executable file to generate.
        /// Do not include file extensions (i.e. ".exe").
        /// </summary>
        /// <param name="execName">Desired name for the executable.</param>
        /// <returns>A copy of this configuration, with the executable name.</returns>
        public BuildConfiguration SetExecName(string execName) {
            var clone = new BuildConfiguration(this);
            clone.execName = execName;
            return clone;
        }

        /// <summary>
        /// Add a scene to the executable. At least one is needed.
        /// </summary>
        /// <param name="scenename">The path of the scene to add, relative to Assets.</param>
        /// <returns>A copy of this configuration, with the scene added.</returns>
        public BuildConfiguration AddScenes(params string[] sceneNames) {
            var clone = new BuildConfiguration(this);
            for (int i = 0; i < sceneNames.Length; ++i)
                clone.scenes.Add("Assets/" + sceneNames[i]);
            return clone;
        }

        /// <summary>
        /// Set the directory where the builds should be placed.
        /// </summary>
        /// <param name="pathName">Path where builds are placed.</param>
        /// <returns>A copy of this configuration, with the target dir.</returns>
        public BuildConfiguration SetTargetDir(string pathName) {
            var clone = new BuildConfiguration(this);
            clone.targetDir = pathName;
            return clone;
        }

        /// <summary>
        /// Add Unity build options. Can do it one by one,
        /// or add a mask of several BuildOptions.
        /// </summary>
        /// <param name="options">Option or options to use when creating the build.</param>
        /// <returns>A copy of this configuration, with the new options.</returns>
        public BuildConfiguration AddBuildOptions(params BuildOptions[] options) {
            BuildOptions merged = BuildOptions.None;
            foreach (var opt in options)
                merged |= opt;

            var clone = new BuildConfiguration(this);
            clone.options |= merged;
            return clone;
        }

        /// <summary>
        /// Remove a previously set build option.
        /// </summary>
        /// <param name="options">Option or options to remove.</param>
        /// <returns>A copy of this configuration, without the given options.</returns>
        public BuildConfiguration RemoveBuildOption(BuildOptions options) {
            var clone = new BuildConfiguration(this);
            clone.options &= ~options;
            return clone;
        }

        /// <summary>
        /// Configure a directory to copy recursively to the target data directory
        /// after the build is completed.
        /// A source directory can only appear once.
        /// </summary>
        /// <param name="projectDirPath">Source directory to copy.</param>
        /// <param name="buildDirPath">Target directory to copy the source to.
        /// The names or relative paths may not coincide.</param>
        /// <returns>A copy of this configuration, with a new directory mapping.</returns>
        public BuildConfiguration AddDirMapping(string projectDirPath, string buildDirPath) {
            var clone = new BuildConfiguration(this);
            clone.dirMappings.Add(projectDirPath, buildDirPath);
            return clone;
        }

        /// <summary>
        /// Remove a directory mapping.
        /// </summary>
        /// <param name="projectDirPath">Project path to not copy.</param>
        /// <returns>A copy of this configuration, without the given directory mapping.</returns>
        public BuildConfiguration RemoveDirMapping(string projectDirPath) {
            var clone = new BuildConfiguration(this);
            clone.dirMappings.Remove(projectDirPath);
            return clone;
        }

        /// <summary>
        /// Copy a file to a target destination, replacing any file in there,
        /// before creating the build.
        /// This can be used to create a copy of a file with a different name.
        /// </summary>
        /// <param name="sourceFilePath">Path of the file to copy to a new destination.</param>
        /// <param name="targetFilePath">Path to copy the file to, including its new name.</param>
        /// <returns></returns>
        public BuildConfiguration AddBuildFileToCopy(string sourceFilePath, string targetFilePath) {
            var clone = new BuildConfiguration(this);
            clone.buildFilesToCopy.Add(sourceFilePath, targetFilePath);
            return clone;
        }

        /// <summary>
        /// Configure a file which shall be copied to the build data directory.
        /// </summary>
        /// <param name="projectFilePath">Path to the file to copy.</param>
        /// <param name="buildFilePath">Path where the file shall be copied.
        /// Names or relative paths may not match.</param>
        /// <returns>A copy of this configuration, with a new file mapping.</returns>
        public BuildConfiguration AddFileMapping(string projectFilePath, string buildFilePath) {
            var clone = new BuildConfiguration(this);
            clone.fileMappings.Add(projectFilePath, buildFilePath);
            return clone;
        }

        /// <summary>
        /// Configure a text file which shall be copied to the build data directory,
        /// replacing line ends with the requested line end style.
        /// </summary>
        /// <param name="projectFilePath">Path to the file to copy.</param>
        /// <param name="buildFilePath">Path where the file shall be copied.
        /// Names or relative paths may not match.</param>
        /// <param name="lineEnd">Style of line ending to use.</param>
        /// <returns>A copy of this configuration, with a new file mapping.</returns>
        public BuildConfiguration AddTextFileMapping(string projectFilePath, string buildFilePath, LineEnd lineEnd) {
            TextFile newTextFile = null;
            switch (lineEnd) {
                case LineEnd.Windows:
                    newTextFile = new WindowsTextFile(projectFilePath);
                    break;
                case LineEnd.Unix:
                    newTextFile = new UnixTextFile(projectFilePath);
                    break;
                default:
                    throw new System.InvalidOperationException("Unknown line end value: '" + lineEnd + "'");
            }

            var clone = new BuildConfiguration(this);
            clone.textFileMappings.Add(newTextFile, buildFilePath);
            return clone;
        }

        /// <summary>
        /// Remove a file from the set of files to copy.
        /// </summary>
        /// <param name="projectFilePath">Path to the file to not copy.</param>
        /// <returns>A copy of this configuration, without the file mapping.</returns>
        public BuildConfiguration RemoveFile(string projectFilePath) {
            var clone = new BuildConfiguration(this);
            clone.fileMappings.Remove(projectFilePath);
            return clone;
        }

        /// <summary>
        /// Indicate files to remove from the build after it is completed.
        /// Use it to remove files copied when copying dirs in bulk,
        /// or files automatically copied by Unity.
        /// </summary>
        /// <param name="buildFilePaths">Relative paths of the files in the build.</param>
        /// <returns>A copy of this configuration, with the new files to delete.</returns>
        public BuildConfiguration AddFilesToDelete(params string[] buildFilePaths) {
            var clone = new BuildConfiguration(this);
            foreach (var path in buildFilePaths)
                clone.filesToDelete.Add(path);
            return clone;
        }

        /// <summary>
        /// Discard a file which was to be deleted after creating the build.
        /// </summary>
        /// <param name="buildFilePath">Relative path of the file in the build.</param>
        /// <returns>A copy of this configuration, minus the file to delete.</returns>
        public BuildConfiguration RemoveFileToDelete(string buildFilePath) {
            var clone = new BuildConfiguration(this);
            clone.filesToDelete.Remove(buildFilePath);
            return clone;
        }

        /// <summary>
        /// Create a new directory in the build directory, once the build is completed.
        /// </summary>
        /// <param name="buildDirPath">Relative path of the directory in the build.</param>
        /// <returns>A copy of this configuration, plus the new directories to create.</returns>
        public BuildConfiguration CreateDir(string buildDirPath) {
            var clone = new BuildConfiguration(this);
            clone.dirsToCreate.Add(buildDirPath);
            return clone;
        }

        /// <summary>
        /// Indicate a directory to remove from the build after it is created.
        /// Use it to remove directories copied in bulk.
        /// </summary>
        /// <param name="buildDirPath">Relative path of the dir in the build.</param>
        /// <returns>A copy of this configuration, plus the dir to delete.</returns>
        public BuildConfiguration AddDirToDelete(string buildDirPath) {
            var clone = new BuildConfiguration(this);
            clone.dirsToDelete.Add(buildDirPath);
            return clone;
        }

        /// <summary>
        /// Discard a dir which was to be deleted after creating the build.
        /// </summary>
        /// <param name="buildDirPath">Relative path of the dir in the build.</param>
        /// <returns>A copy of this configuration, minus the dir to delete.</returns>
        public BuildConfiguration RemoveDirToDelete(string buildDirPath) {
            var clone = new BuildConfiguration(this);
            clone.dirsToDelete.Remove(buildDirPath);
            return clone;
        }

        /// <summary>
        /// Execute a console command before starting the build process.
        /// </summary>
        /// <param name="command">Command to execute. It will be run from a console/terminal.</param>
        /// <param name="path">Absolute or relative path from which the command will be executed.
        /// If ".", it will be executed from the parent of the data directory.</param>
        /// <returns>The output generated by the command.</returns>
        public BuildConfiguration AddPrebuildCommandLine(string command, string path = "..") {
            var clone = new BuildConfiguration(this);
            clone.prebuildCommands.Add(new SystemCommand(command, path));
            return clone;
        }

        /// <summary>
        /// Execute a console command after the build process and all file/directory manipulation.
        /// </summary>
        /// <param name="command">Command to execute. It will be run from a console/terminal.</param>
        /// <param name="path">Absolute or relative path from which the command will be executed.
        /// If ".", it will be executed from the parent of the data directory.</param>
        /// <returns>The output generated by the command.</returns>
        public BuildConfiguration AddPostbuildCommandLine(string command, string path = "..") {
            var clone = new BuildConfiguration(this);
            clone.postbuildCommands.Add(new SystemCommand(command, path));
            return clone;
        }

        /// <summary>
        /// Generate the configured build for the specified target.
        /// </summary>
        /// <param name="target">Target platform of the build.</param>
        public void Build(BuildTarget target) {
            this.CopyPrebuildFiles();

            if (!Directory.Exists(this.targetDir))
                Directory.CreateDirectory(this.targetDir);

            string targetDataDir = null;
            string targetExe = null;

            this.GetTargetPaths(target, out targetDataDir, out targetExe);

            foreach (var command in this.prebuildCommands) {
                if (System.IO.Path.IsPathRooted(command.Path))
                    Debug.Log("Running command '" + command.Command + "' from '" + command.Path + "'");
                else
                    Debug.Log("Running command '" + command.Command + "' from '" + new System.IO.DirectoryInfo(System.IO.Path.Combine(targetDataDir, command.Path)).FullName + "'");

                command.Execute(targetDataDir);
                Debug.Log("Output: " + System.Environment.NewLine + command.Output);
            }

            //Build
            string buildMessage = BuildPipeline.BuildPlayer(this.scenes.ToArray(),
                                                             targetExe,
                                                             target,
                                                             this.options);
            bool buildError = !string.IsNullOrEmpty(buildMessage);
            if (buildError) {
                Debug.LogError("Error building " + targetExe + " for " + target + ": " + buildMessage);
            } else {
                if (this.dirMappings.Any()
                 || this.fileMappings.Any()
                 || this.textFileMappings.Any()
                 || this.filesToDelete.Any()
                 || this.dirsToDelete.Any()
                 || this.dirsToCreate.Any()
                 || this.postbuildCommands.Any()) {
                    if (string.IsNullOrEmpty(targetDataDir)) {
                        Debug.LogError("No targetDataDir defined for target '" + target + "'");
                    } else {
                        try {
                            this.CopyDirMappings(targetDataDir);
                            this.CopyFileMappings(targetDataDir);
                            this.CopyTextFileMappings(targetDataDir);
                            this.DeleteFiles(targetDataDir);
                            this.DeleteDirs(targetDataDir);
                            this.CreateDirs(targetDataDir);

                            foreach (var command in this.postbuildCommands) {
                                if (System.IO.Path.IsPathRooted(command.Path))
                                    Debug.Log("Running command '" + command.Command + "' from '" + command.Path + "'");
                                else
                                    Debug.Log("Running command '" + command.Command + "' from '" + new System.IO.DirectoryInfo(System.IO.Path.Combine(targetDataDir, command.Path)).FullName + "'");

                                command.Execute(targetDataDir);
                                Debug.Log("Output: " + System.Environment.NewLine + command.Output);
                            }

                            Debug.Log(new DirectoryInfo(this.targetDir).FullName + " successfully built");
                        } catch {
                            Debug.LogError("Error executing post build operations for " + new DirectoryInfo(this.targetDir).FullName);
                            throw;
                        }
                    }
                } else
                    Debug.Log(new DirectoryInfo(this.targetDir).FullName + " successfully built");
            }
        }

        private void CopyPrebuildFiles() {
            foreach (var mapping in this.buildFilesToCopy) {
                FileInfo sourceFile = new FileInfo(Application.dataPath + "/" + mapping.Key);
                FileInfo targetFile = new FileInfo(Application.dataPath + "/" + mapping.Value);
                if (!sourceFile.Exists)
                    throw new System.IO.FileNotFoundException("Unable to copy file.", sourceFile.FullName);

                if (!targetFile.Directory.Exists)
                    BuildConfiguration.CreateHierarchy(targetFile.Directory);

                Debug.Log("Copying '" + sourceFile.FullName + "' to '" + targetFile.FullName + "'");
                sourceFile.CopyTo(targetFile.FullName, true);
            }

            if (this.buildFilesToCopy.Any())
                AssetDatabase.Refresh();
        }

        private void CopyDirMappings(string targetDataDir) {
            foreach (var mapping in this.dirMappings) {
                Directory.CreateDirectory(targetDataDir + "/" + mapping.Value);
                CopyFilesRecursively(
                  new DirectoryInfo(Application.dataPath + "/" + mapping.Key),
                  new DirectoryInfo(targetDataDir + "/" + mapping.Value));
            }
        }

        private void CopyFileMappings(string targetDataDir) {
            foreach (var mapping in this.fileMappings) {
                FileInfo sourceFile = new FileInfo(Application.dataPath + "/" + mapping.Key);
                FileInfo targetFile = new FileInfo(targetDataDir + "/" + mapping.Value);
                if (!sourceFile.Exists) {
                    throw new System.IO.FileNotFoundException("Unable to copy file.", sourceFile.FullName);
                }

                if (!targetFile.Directory.Exists) {
                    BuildConfiguration.CreateHierarchy(targetFile.Directory);
                }

                sourceFile.CopyTo(targetFile.FullName, true);
            }
        }

        private void CopyTextFileMappings(string targetDataDir) {
            foreach (var mapping in this.textFileMappings) {
                FileInfo sourceFile = new FileInfo(Application.dataPath + "/" + mapping.Key.File);
                FileInfo targetFile = new FileInfo(targetDataDir + "/" + mapping.Value);
                if (!sourceFile.Exists) {
                    throw new System.IO.FileNotFoundException("Unable to copy file.", sourceFile.FullName);
                }

                if (!targetFile.Directory.Exists) {
                    BuildConfiguration.CreateHierarchy(targetFile.Directory);
                }

                string content = string.Empty;
                using (var readStream = sourceFile.OpenText()) {
                    content = readStream.ReadToEnd();
                }

                if (targetFile.Exists) {
                    targetFile.Delete();
                }

                content = content.Replace("\n", mapping.Key.LineEnding);
                content = content.Replace("\r\n", mapping.Key.LineEnding);
                using (var file = File.CreateText(targetFile.FullName)) {
                    file.Write(content);
                }
            }
        }

        private void DeleteFiles(string targetDataDir) {
            foreach (var fileToDelete in this.filesToDelete) {
                string filePath = targetDataDir + "/" + fileToDelete;
                if (!File.Exists(filePath)) {
                    Debug.LogWarning("File to be deleted '" + filePath + "' was not found.");
                } else {
                    File.Delete(filePath);
                }
            }
        }

        private void DeleteDirs(string targetDataDir) {
            foreach (var dirToDelete in this.dirsToDelete) {
                string dirPath = targetDataDir + "/" + dirToDelete;
                if (!Directory.Exists(dirPath)) {
                    Debug.LogWarning("Directory to be deleted '" + dirPath + "' was not found.");
                } else {
                    Directory.Delete(dirPath, true);
                }
            }
        }

        private void CreateDirs(string targetDataDir) {
            foreach (var dirToCreate in this.dirsToCreate) {
                string dirPath = targetDataDir + "/" + dirToCreate;
                if (Directory.Exists(dirPath))
                    Debug.LogWarning("Directory to be created '" + dirPath + "' does exist already.");
                else
                    Directory.CreateDirectory(dirPath);
            }
        }

        /// <summary>
        /// Create directory hierarchy.
        /// </summary>
        /// <param name="dir">Highest level directory to create.</param>
        private static void CreateHierarchy(DirectoryInfo dir) {
            if (!dir.Parent.Exists) {
                CreateHierarchy(dir.Parent);
            }

            dir.Create();
        }

        /// <summary>
        /// Copy files and directorys recursively from one directory to another.
        /// 
        /// </summary>
        /// <param name="source">Source directory.</param>
        /// <param name="target">Target directory.</param>
        private static void CopyFilesRecursively(DirectoryInfo source, DirectoryInfo target) {
            foreach (DirectoryInfo dir in source.GetDirectories()) {
                string targetDirName = target.FullName + "/" + dir.Name;
                DirectoryInfo targetDir = Directory.Exists(targetDirName)
                  ? new DirectoryInfo(targetDirName)
                  : target.CreateSubdirectory(dir.Name);

                CopyFilesRecursively(dir, targetDir);
            }

            foreach (FileInfo file in source.GetFiles()) {
                if (file.Extension != ".meta") {
                    file.CopyTo(Path.Combine(target.FullName, file.Name));
                }
            }
        }

        /// <summary>
        /// Obtain the build data directory and executable of the desired build,
        /// depending on the specified target.
        /// </summary>
        /// <param name="target">Target platform.</param>
        /// <param name="targetDataDir">Path of the data folder of the build,
        /// as currently configured.</param>
        /// <param name="targetExe">Path of the executable of the build,
        /// as currently configured.</param>
        private void GetTargetPaths(BuildTarget target, out string targetDataDir, out string targetExe) {
            switch (target) {
                case BuildTarget.StandaloneLinux:
                case BuildTarget.StandaloneLinux64:
                case BuildTarget.StandaloneLinuxUniversal:
                    targetDataDir = this.targetDir + "/" + this.execName + "_Data/";
                    targetExe = this.targetDir + "/" + this.execName;
                    break;
                case BuildTarget.StandaloneOSXIntel:
                case BuildTarget.StandaloneOSXIntel64:
                case BuildTarget.StandaloneOSXUniversal:
                    targetDataDir = this.targetDir + "/" + this.execName + ".app" + "/Contents/";
                    targetExe = this.targetDir + "/" + this.execName + ".app";
                    break;
                case BuildTarget.StandaloneWindows:
                case BuildTarget.StandaloneWindows64:
                    targetDataDir = this.targetDir + "/" + this.execName + "_Data/";
                    targetExe = this.targetDir + "/" + this.execName + ".exe";
                    break;
                case BuildTarget.Android:
                    targetDataDir = null;
                    targetExe = this.targetDir + "/" + this.execName + ".apk";
                    break;
                default:
                    Debug.LogWarning("No data dir for target " + target);
                    targetDataDir = null;
                    targetExe = this.targetDir;
                    break;
            }
        }

    }
}
